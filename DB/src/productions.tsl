/*
to do:
trigger
procedure
alias
*/

#include <iostream>
#include <variant>
#include <vector>
#include <string>

#include "query.h"

using namespace std;
using namespace DB;
using namespace DB::Query;

namespace sql
{
	ostream &print_symbol(const long long s);
	```tsl
	terminate = 
	{
		"+", "-", "*", "/", "%",

		AND, OR, 

		"==", "!=", 
		"<", ">", "<=", ">=", 

		"=",

		NUMBER_CONSTANT, ID, STR_LITERAL,

		INT,

		CHAR, VARCHAR, "$",
		NOT_NULL, DISTINCT, VALUES,
		CREATE, DROP, INSERT, DELETE, UPDATE, SELECT, 
		TABLE, "FROM", WHERE, JOIN,
		ORDERBY, ASC, DESC, SET,
		DEFAULT, PRIMARY_KEY, REFERENCES, 

		",", ".", ";",
		"?", ":",
		"(", ")",
		"[", "]",
		"{", "}",
	};
	token_type = lexer::Token;
	get_type = lexer::getType;
	pass_info_struct = {
        //table info buffer
    };

	using sqlStatement = SQLValue;
	using ddlStatement = SQLValue;
	using dmlStatement = SQLValue;
	using createTable = CreateTableInfo;
	using dropTable = DropTableInfo;
	using selectStatement = SelectInfo;
	using insertStatement = InsertInfo;
	using updateStatement = UpdateInfo;
	using deleteStatement = DeleteInfo;
	using tableName = std::string;
	using createDefinitions = std::vector<ColumnInfo>;
	using createDefinition = ColumnInfo;
	using dataType = std::pair<col_t_t, unsigned int>; //type, len
	using columnConstraint = ColumnInfo;
	using insertElement = Elements;
	using updateElements = Elements;
	using updateElement = Element;
	using selectElement = Element;
	using fromClause = std::pair<Source, bool>;	//tables, join
	using orderByClause = std::vector<orderby_element>;
	using orderByExpression = orderby_element;
	using columnName = Column;
	using expressionAtoms = std::vector<BaseExpr*>;
	using expression = BaseExpr*;
	using predicate = BaseExpr*;
	using expressionAtom = AtomExpr*;
	using constantNum = int;
	using positiveNum = int;
	using comparisonOperator = comparison_t_t;
	using logicalOperator = logical_t_t;
	using mathOperator = math_t_t;

	back = {
        cout << "REDUCE: ";
        print_symbol(left.type) << ":= ";
        for (auto &s: right)
            print_symbol(s.type);
        cout << endl << endl;
    };

	sqlStatement := ddlStatement, { $$ = $1; }
				  | dmlStatement, { $$ = $1; }
				  ;


	ddlStatement := createTable, { $$ = $1; }
				  | dropTable, { $$ = $1; }
				  ;


	dmlStatement := selectStatement, { $$ = $1; }
				  | insertStatement, { $$ = $1; }
				  | updateStatement, { $$ = $1; }
				  | deleteStatement, { $$ = $1; }
				  ;

	// Data Definition Language

	createTable := "CREATE" "TABLE" tableName createDefinitions,
				 {
					$$.tableName = $3;
					$$.columnInfos = $4;
					$$.reset();
				 }
				 ;

	dropTable := "DROP" "TABLE" tableName, { $$ = $3; }
			   ;

	createDefinitions := "(" createDefinition [{"," createDefinition}*] ")", =
					   {
						   auto& l = std::get<vector<ColumnInfo>>(left.object);
						   size_t size = right.size();
						   for(size_t i = 1; i < size; i += 2)
						   {
							   l.push_back(get<ColumnInfo>(right[i].object));
						   }
					   }
					   ;

	// need tableConstraint
	createDefinition := "ID" dataType columnConstraint*, =
					  {
						  auto& l = std::get<ColumnInfo>(left.object);
						  l.columnName = get<string>(get<Token>(right[0].object)._token);
						  auto& type_len = get<pair<col_t_t, unsigned int>>(right[1].object);
						  l.col_t_ = type_len.first;
						  l.str_len_ = type_len.second;

						  //no duplicate checking on columnConstraint,
						  //the last one overwrite the original
						  size_t size = right.size();
						  for(size_t i = 2; i < size; ++i)
						  {
							  ColumnInfo& column = get<ColumnInfo>(right[i].object);
							  if(column.isPK())
							  {
								  l.setPK();
							  }
							  else if(column.isFK())
							  {
								  l.setFK();
								  l.fkTable = column.fkTable;
							  }
							  else if(column.isNOT_NULL())
							  {
								  l.setNOT_NULL();
							  }
							  else if(column.isDEFAULT())
							  {
								  l.setDEFAULT();
								  l.defaultStr = column.defaultStr;
								  l.defaultInt = column.defaultInt;
							  }
						  }

					  }
					  ;

	dataType := "INT", { $$ = make_pair(col_t_t::INT, 0); }
			  | "CHAR" "(" positiveNum ")", { $$ = make_pair(col_t_t::CHAR, $3); }
			  | "VARCHAR" "(" positiveNum ")", { $$ = make_pair(col_t_t::VARCHAR, $3); }
			  ;

	columnConstraint := "NOT_NULL", { $$.setNOT_NULL(); }
					  | "DEFAULT" expressionAtom,
					  {
						  $$.setDEFAULT();
						  RetValue val = vmVisit($2);
						  if(auto op = get_if<int>(&val))
						  {
							  $$.defaultInt = *op;
						  }
						  else if(auto op = get_if<string>(&val))
						  {
							  $$.defaultStr = *op;
						  }
					  }
					  | "PRIMARY_KEY", { $$.setPK(); }
					  | "REFERENCES" tableName,
					  {
						  $$.setFK();
						  $$.fkTable = $2;
					  }
					  ;


	// Data Manipulation Language
	insertStatement := "INSERT" tableName ["(" "ID" [{"," "ID"}*] ")"] insertElements, =
					 {
						 //match ID and value in insertElement
						auto& l = std::get<InsertInfo>(left.object);
						vector<string> columnNames;
						size_t size = right.size();
						for(size_t i = 3; i < size - 2; i += 2)
						{
							columnNames.push_back(get<string>(get<Token>(right[i].object)._token));
						}
						auto& values = get<Elements>(right[size-1].object);
						if(columnNames.size() != values.size())
							throw DB_Exception("the number of columns and values don't match");
						
						for(size_t i = 0; i < values.size(); ++)
						{
							values[i].name = columnNames[i];
						}
						l.sourceTable = get<string>(right[1].object);
						l.values = values;
					 }
					 ;

	deleteStatement := "DELETE" "FROM" tableName ["WHERE" expression], =
					 {
						 auto& l = std::get<DeleteInfo>(left.object);
						 l.sourceTable = get<string>(right[2].object);
						 if(right.size() == 5)
						 {
							 l.whereExpr = get<BaseExpr*>(right[4].object);
							 outputVisit(l.whereExpr);
							 checkVisit(l.whereExpr);
						 }
					 }
					 ;

	updateStatement := "UPDATE" tableName "SET" updateElements ["WHERE" expression], =
					 {
						 auto& l = std::get<UpdateInfo>(left.object);
						 l.sourceTable = get<string>(right[1].object);
						 if(right.size() == 6)
						 {
							 l.whereExpr = get<BaseExpr*>(right[5].object);
							 outputVisit(l.whereExpr);
							 checkVisit(l.whereExpr);
						 }
					 }
					 ;

	// need  ["DISTINCT"]
	selectStatement := "SELECT" selectElement [fromClause] ["WHERE" expression] [orderByClause]
					 ;

	// need selectStatement
	insertElements := "VALUES" "(" expressionAtom [{"," expressionAtom}*] ")", =
					{
						auto& l = std::get<Elements>(left.object);
						size_t size = right.size();
						for(size_t i = 0; i < size; i += 2)
						{
							Element ele;
							ele.valueExpr = get<BaseExpr*>(right[i].object);
							outputVisit(ele.valueExpr);
							checkVisit(ele.valueExpr);
							l.push_back(ele);
						}
					}
					;
	
	updateElements := updateElement [{"," updateElement}*], =
					{
						auto& l = std::get<Elements>(left.object);
						size_t size = right.size();
						for(size_t i = 0; i < size; i += 2)
						{
							l.push_back(get<Element>(right[i].object));
						}
					}
					;

	updateElement := columnName "=" {expressionAtom | "DEFAULT"}, =
				   {
					   auto& l = std::get<Element>(left.object);
					   l.name = std::get<string>(right[0].object);
					   if(auto expr = get_if<BaseExpr*>(right[2].object))
					   {
						   l.isDefault = false;
						   l.valueExpr = *expr;
						   outputVisit(l.valueExpr);
						   checkVisit(l.valueExpr);
					   }
					   else
					   {
						   l.isDefault = true;
					   }
				   }
				   ;	  
						  
	// Select Statement"s Details
	selectElement := "$",
				   {
					   //need change
					   //empty elements means all, checked in statement
				   }
				   | expressionAtom [{"," expressionAtom}*]
				   ;

	orderByClause := "ORDERBY" orderByExpression [{"," orderByExpression}*], =
				   {
					   auto& l = std::get<vector<orderby_element>>(left.object);
					   size_t size = right.size();
					   for(size_t i = 1; i < size; i += 2)
					   {
						   	l.push_back(get<orderby_element>(right[i].object));
					   }
				   }
				   ;

	orderByExpression := expressionAtom ["ASC"|"DESC"], =
					   {
						   auto& l = std::get<orderby_element>(left.object);
						   l.first = get<BaseExpr*>(right[0].object);
						   outputVisit(l.first);
						   checkVisit(l.first);
						   if(right.size() == 1 || 
						   	get<type>(get<Token>(right[1].object)._token) == type::ASC)
						   {
							   l.second = true;
						   }
						   else
						   {
							   l.second = false;
						   }
					   }
					   ;

	fromClause := "FROM" tableName [{"," tableName}*], =
				{
					auto& l = std::get<pair<Source, bool>>(left.object);
					vector<string> tables;
					size_t size = right.size();
					for(size_t i = 1; i < size; i += 2)
					{
						l.push_back(get<string>(right[i].object));
					}
					l = make_pair(tables, false);
				}
				| "FROM" tableName "JOIN" tableName,
				{
					vector<string> tables = {$2, $4};
					$$ = make_pair(tables, true);
				}
				;


	tableName := "ID", { $$ = std::get<std::string>($1._token); }
			   ;

	columnName := "ID" "." "ID", { $$ = make_pair($1, $2); }
				| "ID", { $$ = make_pair("", $1); }
				;

	expressionAtoms := 

	left logicOp;

	expression := expression logicalOperator expression, logicOp,
				{
					$$ = new LogicalOpExpr($2, $1, $3);
				}
				| predicate, { $$ = $1; }
				;

	// predicate need (in select) and (like) form and (exists)
	predicate := expressionAtom comparisonOperator expressionAtom,
			   {
				   $$ = new ComparisonOpExpr($2, $1, $3);
			   }
			   | expressionAtom, { $$ = $1; }
			   ;

	expressionAtom  := constantNum, 
					 {
						 $$ = new NumericExpr($1);
					 }
					 | "STR_LITERAL",
					 {
						 $$ = new StrExpr(std::get<string>($1._token));
					 }
					 | columnName,
					 {
						 $$ = new IdExpr($1.seconde, $1.first);
					 }
					 | expressionAtom mathOperator expressionAto, left,
					 {
						$$ = new MathOpExpr($2, $1, $3);
					 }
					 ;

	constantNum := ["-"] positiveNum, =
				 {
					 auto& l = std::get<int>(left.object);
					 if(right.size() > 1)
					 {
						 int val = std::get<int>(right[1].object);
						 l = -val;
					 }
					 else
					 {
						 l = std::get<int>(right[0].object);
					 }
				 }
				 ;
	
	positiveNum := "NUMBER_CONSTANT", { $$ = std::get<int>($1._token) }
				 ;
				 
	comparisonOperator := "==", { $$ = comparison_t_t::EQ; }
						| ">", { $$ = comparison_t_t::GREATER; }
						| "<", { $$ = comparison_t_t::LESS; }
						| "<=", { $$ = comparison_t_t::LEQ; }
						| ">=", { $$ = comparison_t_t::GEQ; }
						| "!=", { $$ = comparison_t_t::NEQ; }
						;

	logicalOperator := "AND", logicOp, { $$ = logical_t_t::AND; }
					 | "OR", logicOp, { $$ = logical_t_t::OR; }
					 ;
	rank {
		mathOperator := "*", 0, { $$ = math_t_t::MUL; }
					  | "/", 0, { $$ = math_t_t::DIV; }
					  | "%", 1, { $$ = math_t_t::MOD; }
					  | "+", 2, { $$ = math_t_t::ADD; }
					  | "-", 2, { $$ = math_t_t::SUB; }
					  ;
    }
	```
	ostream &print_symbol(const long long s) {
        if (s < 0)
            return std::cout << utils::type_name_map[s] << " ";
        else
            return std::cout << std::quoted(utils::type_name_map[s]) << " ";
    }
}

string trim(string& str)
{
	//trim white space at the very beginning and end
	size_t start = 0, end = str.size() - 1;
	while(str[start] == ' ')
		++start;
	while(str[end] == ' ')
		--end;
	return str.substr(start, end - start);
}

void run()
{
	string tempSql = "";
	auto res = sql::analyze(trim(tempSql));
	//cout 
	return;
}