/*
to do:
trigger
procedure
alias
*/

#include <iostream>
#include <variant>
#include <vector>
#include <string>

#include "query.h"

using namespace std;
using namespace DB;
using namespace DB::Query;

namespace sql
{
	ostream &print_symbol(const long long s);
	```tsl
	terminate = 
	{
		"+", "-", "*", "/", "%",

		AND, OR, 

		"==", "!=", 
		"<", ">", "<=", ">=", 

		"=",

		NUMBER_CONSTANT, ID, STR_LITERAL,

		INT,

		CHAR, VARCHAR, "$",
		NOT_NULL, DISTINCT, VALUES,
		CREATE, DROP, INSERT, DELETE, UPDATE, SELECT, 
		TABLE, "FROM", WHERE, JOIN,
		ORDERBY, ASC, DESC, SET,
		DEFAULT, PRIMARY_KEY, REFERENCES, 

		",", ".", ";",
		"?", ":",
		"(", ")",
		"[", "]",
		"{", "}",
	};
	token_type = lexer::Token;
	get_type = lexer::getType;
	pass_info_struct = {
        //table info buffer
    };

	using sqlStatement = SQLValue;
	using ddlStatement = SQLValue;
	using dmlStatement = SQLValue;
	using createTable = CreateTableInfo;
	using dropTable = DropTableInfo;
	using selectStatement = SelectInfo;
	using insertStatement = InsertInfo;
	using updateStatement = UpdateInfo;
	using deleteStatement = DeleteInfo;
	using tableName = std::string;
	using createDefinitions = std::vector<ColumnInfo>;
	using createDefinition = ColumnInfo;
	using dataType = std::pair<col_t_t, unsigned int>; //type, len
	using columnConstraint = ColumnInfo;
	using insertElement = Elements;
	using updateElement = Elements;
	using selectElement = Elements;
	using fromClause = std::pair<Source, bool>;	//tables, join
	using orderByClause = std::vector<orderby_element>;
	using orderByExpression = orderby_element;
	using columnName = Column;
	using expressionAtoms = std::vector<BaseExpr*>;
	using expression = BaseExpr*;
	using predicate = BaseExpr*;
	using expressionAtom = AtomExpr*;
	using constantNum = int;
	using positiveNum = int;
	using comparisonOperator = comparison_t_t;
	using logicalOperator = logical_t_t;
	using mathOperator = math_t_t;

	back = {
        cout << "REDUCE: ";
        print_symbol(left.type) << ":= ";
        for (auto &s: right)
            print_symbol(s.type);
        cout << endl << endl;
    };

	sqlStatement := ddlStatement, { $$ = $1; }
				  | dmlStatement, { $$ = $1; }
				  ;


	ddlStatement := createTable, { $$ = $1; }
				  | dropTable, { $$ = $1; }
				  ;


	dmlStatement := selectStatement, { $$ = $1; }
				  | insertStatement, { $$ = $1; }
				  | updateStatement, { $$ = $1; }
				  | deleteStatement, { $$ = $1; }
				  ;

	// Data Definition Language

	createTable := "CREATE" "TABLE" tableName createDefinitions,
				 {
					$$.tableName = $3;
					$$.columnInfos = $4;
					$$.reset();
				 }
				 ;

	dropTable := "DROP" "TABLE" tableName, { $$ = $3; }
			   ;

	createDefinitions := "(" createDefinition [{"," createDefinition}*] ")"
					   ;

	// need tableConstraint
	createDefinition := "ID" dataType columnConstraint*, =
					  {
						  //not default
						  $$.columnName = std::get<std::string>($1._token);
						  $$.col_t_ = $2.first;
						  $$.str_len_ = $2.second;
						  constraint_t_ //ColumnInfos into one
					  }
					  ;

	dataType := "INT", { $$ = make_pair(col_t_t::INT, 0); }
			  | "CHAR" "(" positiveNum ")", { $$ = make_pair(col_t_t::CHAR, $3); }
			  | "VARCHAR" "(" positiveNum ")", { $$ = make_pair(col_t_t::VARCHAR, $3); }
			  ;

	columnConstraint := "NOT_NULL", { $$.setNOT_NULL(); }
					  | "DEFAULT" expressionAtom,
					  {
						  $$.setDEFAULT();
						  RetValue val = vmVisit($2);
						  if(auto op = get_if<int>(&val))
						  {
							  $$.defaultInt = *op;
						  }
						  else if(auto op = get_if<string>(&val))
						  {
							  $$.defaultStr = *op;
						  }
					  }
					  | "PRIMARY_KEY", { $$.setPK(); }
					  | "REFERENCES" tableName,
					  {
						  $$.setFK();
						  $$.fkTable = $2;
					  }
					  ;


	// Data Manipulation Language
	insertStatement := "INSERT" tableName ["(" "ID" [{"," "ID"}*] ")"] insertElement
					 ;

	deleteStatement := "DELETE" "FROM" tableName ["WHERE" expression]
					 ;

	updateStatement := "UPDATE" tableName "SET" updateElement [{"," updateElement}*] ["WHERE" expression]
					 ;

	selectStatement := "SELECT" ["DISTINCT"] selectElement [fromClause] ["WHERE" expression] [orderByClause]
					 ;

	// need selectStatement
	insertElement := "VALUES" "(" expressionAtoms ")" [{"," "(" expressionAtoms ")"}*]
						  ;
	updateElement := columnName "=" {expressionAtom | "DEFAULT"}
				   ;	  
						  
	// Select Statement"s Details
	selectElement := "$",
				   {
					   //empty elements means all, checked in statement
				   }
				   | expressionAtom [{"," expressionAtom}*]
				   ;

	orderByClause := "ORDERBY" orderByExpression [{"," orderByExpression}*]
				   ;

	orderByExpression := expressionAtom ["ASC"|"DESC"]
					   ;

	fromClause := "FROM" tableName ["," tableName]
				| "FROM" tableName "JOIN" tableName,
				{
					vector<string> tables = {$2, $4};
					$$ = make_pair(tables, true);
				}
				;


	tableName := "ID", { $$ = std::get<std::string>($1._token); }
			   ;

	columnName := "ID" "." "ID", { $$ = make_pair($1, $2); }
				| "ID", { $$ = make_pair("", $1); }
				;

	expressionAtoms := expressionAtom [{"," expressionAtom}*]
				 ;

	left logicOp;

	expression := expression logicalOperator expression, logicOp
				| predicate
				;

	// predicate need (in select) and (like) form and (exists)
	predicate := expressionAtom comparisonOperator expressionAtom
			   | expressionAtom
			   ;

	expressionAtom  := constantNum, 
					 {
						 $$ = new 

					 }
					 | "STR_LITERAL",
					 {

					 }
					 | columnName,
					 {

					 }
					 | expressionAtom mathOperator expressionAto, left,
					 {

					 }
					 ;

	constantNum := ["-"] positiveNum
				 ;
	
	positiveNum := "NUMBER_CONSTANT", { $$ = std::get<int>($1._token) }
				 ;
				 
	comparisonOperator := "==", { $$ = comparison_t_t::EQ; }
						| ">", { $$ = comparison_t_t::GREATER; }
						| "<", { $$ = comparison_t_t::LESS; }
						| "<=", { $$ = comparison_t_t::LEQ; }
						| ">=", { $$ = comparison_t_t::GEQ; }
						| "!=", { $$ = comparison_t_t::NEQ; }
						;

	logicalOperator := "AND", logicOp, { $$ = logical_t_t::AND; }
					 | "OR", logicOp, { $$ = logical_t_t::OR; }
					 ;
	rank {
		mathOperator := "*", 0, { $$ = math_t_t::MUL; }
					  | "/", 0, { $$ = math_t_t::DIV; }
					  | "%", 1, { $$ = math_t_t::MOD; }
					  | "+", 2, { $$ = math_t_t::ADD; }
					  | "-", 2, { $$ = math_t_t::SUB; }
					  ;
    }
	```
	ostream &print_symbol(const long long s) {
        if (s < 0)
            return std::cout << utils::type_name_map[s] << " ";
        else
            return std::cout << std::quoted(utils::type_name_map[s]) << " ";
    }
}

string trim(string& str)
{
	//trim white space at the very beginning and end
	size_t start = 0, end = str.size() - 1;
	while(str[start] == ' ')
		++start;
	while(str[end] == ' ')
		--end;
	return str.substr(start, end - start);
}

void run()
{
	string tempSql = "";
	auto res = sql::analyze(trim(tempSql));
	//cout 
	return;
}