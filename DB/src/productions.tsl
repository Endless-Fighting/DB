/*
to do:
trigger
procedure
alias
*/

#include <iostream>
#include <vector>
#include <string>

using namespace std;

namespace sql
{

	```tsl
	terminate = 
	{
		"+", "-", "*", "/", "%",

		NOT, AND, OR, 

		"==", "!=", 
		"<", ">", "<=", ">=", 

		"=",

		NUMBER_CONSTANT, ID, STR_LITERAL,

		INT,

		CHAR, VARCHAR, "$",
		NULL, DISTINCT, VALUES,
		CREATE, DROP, INSERT, DELETE, UPDATE, SELECT, 
		TABLE, "FROM", WHERE, JOIN,
		ORDERBY, ASC, DESC, SET,
		DEFAULT, PRIMARY_KEY, REFERENCES, 

		",", ".", ";",
		"?", ":",
		"(", ")",
		"[", "]",
		"{", "}",
	};
	token_type = lexer::Token;
	get_type = lexer::getType;


	sqlStatement := ddlStatement
				  | dmlStatement
				  ;


	ddlStatement := createTable
				  | dropTable
				  ;


	dmlStatement := selectStatement
				  | insertStatement
				  | updateStatement
				  | deleteStatement
				  ;

	// Data Definition Language

	createTable := "CREATE" "TABLE" tableName createDefinitions
				 ;

	dropTable := "DROP" "TABLE" tableName
			   ;

	createDefinitions := "(" createDefinition ["," createDefinition]* ")"
					   ;

	// need tableConstraint
	createDefinition := "ID" columnDefinition
					  ;

	columnDefinition := dataType columnConstraint*
					  ;

	dataType := "INT"
			  | "CHAR" "(" positiveNum ")"
			  | "VARCHAR" "(" positiveNum ")"
			  ;

	columnConstraint := "NOT" "NULL"
					  | "DEFAULT" expression
					  | "PRIMARY_KEY"
					  | referenceDefinition
					  ;

	referenceDefinition := "REFERENCES" tableName "(" "ID" ")"
						 ;

	// Data Manipulation Language
	insertStatement := "INSERT" tableName ["(" "ID" ["," "ID"]* ")"] insertStatementValue
					 ;

	deleteStatement := "DELETE" "FROM" tableName ["WHERE" expression]
					 ;

	updateStatement := "UPDATE" tableName "SET" updateElement ["," updateElement]* ["WHERE" expression]
					 ;

	selectStatement := "SELECT" ["DISTINCT"] selectElements [fromClause] ["WHERE" expression] [orderByClause]
					 ;

	// need selectStatement
	insertStatementValue := "VALUES" "(" expressions ")" ["," "(" expressions ")"]*
						  ;
	updateElement := columnName "=" {expression | "DEFAULT"}
				   ;	  
						  
	// Select Statement"s Details
	selectElement := "$"
				   | columnName ["," columnName]*
				   ;

	orderByClause := "ORDERBY" orderByExpression ["," orderByExpression]*
				   ;

	orderByExpression := expressionAtom ["ASC"|"DESC"]
					   ;

	fromClause := "FROM" tableName ["," tableName]
				| "FROM" tableName "JOIN" tableName
				;


	tableName := "ID"
			   ;

	columnName := "ID" "." "ID"
				| "ID"
				;

	expressions := expression ["," expression]*
				 ;

	left logicOp;
	rank logicOpRank;

	expression := expression logicalOperator expression, logicOp logicOpRank 2
				| "NOT" expression, logicOpRank 1
				| predicate
				;

	// predicate need (in select) and (like) form and (exists)
	predicate := expressionAtom comparisonOperator expressionAtom
			   | expressionAtom
			   ;

	expressionAtom  := constantNum
					 | "STR_LITERAL"
					 | columnName
					 | expressionAtom mathOperator expressionAto, left
					 ;

	constantNum := ["-"] positiveNum
				 ;
	
	positiveNum := "NUMBER_CONSTANT"
				 ;
				 
	comparisonOperator := "=="
						| ">"
						| "<"
						| "<="
						| ">="
						| "!="
						;

	logicalOperator := "AND", logicOp logicOpRank 2
					 | "OR", logicOp logicOpRank 2
					 ;
	rank {
		mathOperator := "*", 0
					  | "/", 0
					  | "%", 1
					  | "+", 2
					  | "-", 2
					  ;
    }
	```
}

string trim(string& str)
{
	//trim white space at the very beginning and end
	size_t start = 0, end = str.size() - 1;
	while(str[start] == ' ')
		++start;
	while(str[end] == ' ')
		--end;
	return str.substr(start, end - start);
}

void run()
{
	string tempSql = "";
	auto res = sql::analyze(trim(tempSql));
	//cout 
	return;
}