/*
to do:
trigger
procedure
alias
*/

#include <iostream>
#include <variant>
#include <vector>
#include <string>

#include "ast.h"

using namespace std;
using namespace DB::AST;

namespace sql
{
	ostream &print_symbol(const long long s);
	```tsl
	terminate = 
	{
		"+", "-", "*", "/", "%",

		AND, OR, 

		"==", "!=", 
		"<", ">", "<=", ">=", 

		"=",

		NUMBER_CONSTANT, ID, STR_LITERAL,

		INT,

		CHAR, VARCHAR, "$",
		NULL, DISTINCT, VALUES,
		CREATE, DROP, INSERT, DELETE, UPDATE, SELECT, 
		TABLE, "FROM", WHERE, JOIN,
		ORDERBY, ASC, DESC, SET,
		DEFAULT, PRIMARY_KEY, REFERENCES, 

		",", ".", ";",
		"?", ":",
		"(", ")",
		"[", "]",
		"{", "}",
	};
	token_type = lexer::Token;
	get_type = lexer::getType;
	pass_info_struct = {
        
    };

	using sqlStatement = SQLValue;
	using ddlStatement = SQLValue;
	using dmlStatement = SQLValue;
	using createTable = CreateTableInfo;
	using dropTable = DropTableInfo;
	using selectStatement = SelectInfo;
	using insertStatement = InsertInfo;
	using updateStatement = UpdateInfo;
	using deleteStatement = DeleteInfo;
	using tableName = std::string;
	using createDefinitions = std::vector<ColumnInfo*>;
	using createDefinition = ColumnInfo*;
	using columnDefinition = unsigned int;
	using dataType = col_t_t;
	using columnConstraint = constraint_t_t;
	using insertElement = Elements;
	using updateElement = Elements;
	using selectElement = Elements;
	using fromClause = std::pair<Source, bool>;
	using orderByClause = std::vector<orderby_element>;
	using orderByExpression = orderby_element;
	using columnName = std::pair<std::string, std::string>; // table.column
	using expressionAtoms = std::vector<BaseExpr*>;
	using expression = BaseExpr*;
	using predicate = BaseExpr*;
	using expressionAtom = AtomExpr*;
	using constantNum = int;
	using positiveNum = int;
	using comparisonOperator = comparison_t_t;
	using logicalOperator = logical_t_t;
	using mathOperator = math_t_t;

	back = {
        cout << "REDUCE: ";
        print_symbol(left.type) << ":= ";
        for (auto &s: right)
            print_symbol(s.type);
        cout << endl << endl;
    };

	sqlStatement := ddlStatement
				  | dmlStatement
				  ;


	ddlStatement := createTable
				  | dropTable
				  ;


	dmlStatement := selectStatement
				  | insertStatement
				  | updateStatement
				  | deleteStatement
				  ;

	// Data Definition Language

	createTable := "CREATE" "TABLE" tableName createDefinitions
				 ;

	dropTable := "DROP" "TABLE" tableName
			   ;

	createDefinitions := "(" createDefinition [{"," createDefinition}*] ")"
					   ;

	// need tableConstraint
	createDefinition := "ID" columnDefinition
					  ;

	columnDefinition := dataType columnConstraint*
					  ;

	dataType := "INT"
			  | "CHAR" "(" positiveNum ")"
			  | "VARCHAR" "(" positiveNum ")"
			  ;

	columnConstraint := "NOT" "NULL"
					  | "DEFAULT" expressionAtom
					  | "PRIMARY_KEY"
					  | "REFERENCES" tableName "(" "ID" ")"
					  ;


	// Data Manipulation Language
	insertStatement := "INSERT" tableName ["(" "ID" [{"," "ID"}*] ")"] insertElement
					 ;

	deleteStatement := "DELETE" "FROM" tableName ["WHERE" expression]
					 ;

	updateStatement := "UPDATE" tableName "SET" updateElement [{"," updateElement}*] ["WHERE" expression]
					 ;

	selectStatement := "SELECT" ["DISTINCT"] selectElement [fromClause] ["WHERE" expression] [orderByClause]
					 ;

	// need selectStatement
	insertElement := "VALUES" "(" expressionAtoms ")" [{"," "(" expressionAtoms ")"}*]
						  ;
	updateElement := columnName "=" {expressionAtom | "DEFAULT"}
				   ;	  
						  
	// Select Statement"s Details
	selectElement := "$"
				   | expressionAtom [{"," expressionAtom}*]
				   ;

	orderByClause := "ORDERBY" orderByExpression [{"," orderByExpression}*]
				   ;

	orderByExpression := expressionAtom ["ASC"|"DESC"]
					   ;

	fromClause := "FROM" tableName ["," tableName]
				| "FROM" tableName "JOIN" tableName
				;


	tableName := "ID"
			   ;

	columnName := "ID" "." "ID"
				| "ID"
				;

	expressionAtoms := expressionAtom [{"," expressionAtom}*]
				 ;

	left logicOp;

	expression := expression logicalOperator expression, logicOp
				| predicate
				;

	// predicate need (in select) and (like) form and (exists)
	predicate := expressionAtom comparisonOperator expressionAtom
			   | expressionAtom
			   ;

	expressionAtom  := constantNum
					 | "STR_LITERAL"
					 | columnName
					 | expressionAtom mathOperator expressionAto, left
					 ;

	constantNum := ["-"] positiveNum
				 ;
	
	positiveNum := "NUMBER_CONSTANT"
				 ;
				 
	comparisonOperator := "=="
						| ">"
						| "<"
						| "<="
						| ">="
						| "!="
						;

	logicalOperator := "AND", logicOp
					 | "OR", logicOp
					 ;
	rank {
		mathOperator := "*", 0
					  | "/", 0
					  | "%", 1
					  | "+", 2
					  | "-", 2
					  ;
    }
	```
	ostream &print_symbol(const long long s) {
        if (s < 0)
            return std::cout << utils::type_name_map[s] << " ";
        else
            return std::cout << std::quoted(utils::type_name_map[s]) << " ";
    }
}

string trim(string& str)
{
	//trim white space at the very beginning and end
	size_t start = 0, end = str.size() - 1;
	while(str[start] == ' ')
		++start;
	while(str[end] == ' ')
		--end;
	return str.substr(start, end - start);
}

void run()
{
	string tempSql = "";
	auto res = sql::analyze(trim(tempSql));
	//cout 
	return;
}